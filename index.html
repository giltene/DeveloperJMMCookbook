<!DOCTYPE html>
<html>
<head>
<title>The JMM Cookbook for Java Developers</title>

<meta http-equiv="content-type"
content="text/html; charset=ISO-8859-1">

<meta name="author" content="Gil Tene">
</head>
<body style="background-color: #ffffee;">

<h1>The JMM Cookbook for Java Developers</h1>

by <a href="https://twitter.com/giltene">Gil Tene</a>, with help from
a sleepless night and confusion about which day it was.
<p><b>Note: This cookbook is not currently known to be correct. It is a hopeful draft. Treat it as such.</b></p>
<p> 
<a href="http://g.oswego.edu/dl/jmm/cookbook.html">
Doug Lea's JSR-133 Cookbook for Compiler Writers
</a>
    (aka "the JMM cookbook") describes a set of implementation rules that is
    sufficient for meeting the JMM specification. The cookbook is an amazingly
    useful tool for Compiler Writers and JVM implementers, which is it's stated
    purpose. It describes a set of implementation rules that is sufficient
    for meeting the JMM specification, and is used by most JVMs, most of
    the time. The simple ordering matrices described provide great guidelines that
    are easy to follow and reason about.
</p>
<p>
    However, being a sufficient-but-not-necessary set of rules, this
    Compiler Writer's JMM Cookbook does not provide Java developers with
    a tool to reason about the rules that are *guaranteed* to be followed
    by any JVM compliant with the JMM specification.
    While many JVM implementations follow these cookbook rules in
    order to meet the JMM specification, it can be dangerous for Java
    developers to assume that the rules stated are guarantees, a JVM
    implementations that meet the JMM specification but use more relaxed rules
    that stated in the JMM cookbook are certainly possible. The barrier
    matrices in the cookbook, as easy as they are to understand and follow,
    are not a reliable predictor of what JVMs will actually do now or in
    the future.
</p>
<p>
    This leaves Java developers with the JMM specification itself, which is
    unfortunately not reliably parse-able by mortals on a daily basis.
    Applying JMM spec criteria to code requires a level of transcendent
    meditation that is not only hard to achieve, but more importantly hard
    to maintain, making it impractical for daily reference use by programmers
    that want to actually construct "safe" code. This is most easily
    evidenced by the occasional storms of e-mails and mailing list
    disagreements among people who actually spend much of their time
    specifying, implementing, and testing memory models.
</p>
<p>
    So What's a Java developer to do?
</p>

<h3>Gil's expanded barrier table</h3>

<p> 
I've been playing with an attempt to describe the required (rather than
just a sufficient) reordering limitations that result from the JMM spec
in a way that can be more readily consumed by Java developers that want
to reason about their own programs, and to understand the guarantees
provided to them by the JMM.
</p>

<p> 
I believe that the following matix, using Doug's convenient format,
describes required (rather than simply sufficient) reordering rules
between the common operations of Load, Store, Volatile Load, Volatile Store,
Monitor Enter, and Monitor Exit.
</p>

<p>
The matrix uses Doug's original notation for  
<span style="color: red; ">LoadLoad</span>,
<span style="color: red; ">LoadStore</span>,
<span style="color: red; ">StoreStore</span> and
<span style="color: red; ">StoreLoad</span> barriers used in the JMM cookbook's
most commonly referred to matrix, in
addition to his expanded use of the following:
<span style="color: red; ">LoadExit</span>,
<span style="color: red; ">StoreExit</span>,
<span style="color: red; ">EnterEnter</span>,
<span style="color: red; ">EnterExit</span>,
<span style="color: red; ">ExitExit</span>,
<span style="color: red; ">ExitEnter</span>,
<span style="color: red; ">EnterLoad</span>,
<span style="color: red; ">EnterStore</span>.
Into that mix, We throw in the additional
<span style="color: red; ">"VLoad"</span> and
<span style="color: red; ">"VStore"</span>
notation to expand the set with
<span style="color: red; ">LoadVStore</span>,
<span style="color: red; ">LoadVLoad</span>,
<span style="color: red; ">StoreVStore</span>,
<span style="color: red; ">VLoadLoad</span>,
<span style="color: red; ">VLoadStore</span>,
<span style="color: red; ">VLoadVLoad</span>,
<span style="color: red; ">VLoadVStore</span>,
<span style="color: red; ">VLoadEnter</span>,
<span style="color: red; ">VLoadExit</span>,
<span style="color: red; ">VStoreVLoad</span>,
<span style="color: red; ">VStoreVStore</span>,
<span style="color: red; ">VStoreEnter</span>,
<span style="color: red; ">VStoreExit</span>,
<span style="color: red; ">ExitVLoad</span>,
<span style="color: red; ">ExitVStore</span>.



<p> I believe that Fully expanding to explicitly address ordering rules for Loads, Stores, Volatile Loads, Volatile Stores, Monitor Enter and Monitor Exit disentangles to: </p>

<table cellpadding="2" cellspacing="2" border="1" >
  <tbody>
  <tr>
    <td><b>Required Barriers</b>
    </td>
    <td rowspan="1" colspan="6" align="center"><em>2nd operation</em>
    </td>
  </tr>
  <tr>
    <td><em>1st operation</em>
    </td>
    <td>Normal Load
    </td>
    <td>Normal Store
    </td>
    <td>Volatile Load
    </td>
    <td>Volatile Store
    </td>
    <td>MonitorEnter
    </td>
    <td>MonitorExit
    </td>
  </tr>
  <tr>
    <td>Normal Load
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><span style="color: red; ">LoadVStore</span>
    </td>
    <td><br>
    </td>
    <td><span style="color: red; ">LoadExit</span>
    </td>
  </tr>
  <tr>
    <td>Normal Store
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><span style="color: red; ">StoreVStore</span>
    </td>
    <td><br>
    </td>
    <td><span style="color: red; ">StoreExit</span>
    </td>
  </tr>
  <tr>
    <td>Volatile Load
    </td>
    <td><span style="color: red; ">VLoadLoad</span>
    </td>
    <td><span style="color: red; ">VLoadStore</span>
    </td>
    <td><span style="color: red; ">VLoadVLoad</span>
    </td>
    <td><span style="color: red; ">VLoadVStore</span>
    </td>
    <td><span style="color: red; ">VLoadEnter</span>
    </td>
    <td><span style="color: red; ">VLoadExit</span>
    </td>
  </tr>
  <tr>
    <td>Volatile Store
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><span style="color: red; ">VStoreVLoad</span>
    </td>
    <td><span style="color: red; ">VStoreVStore</span>
    </td>
    <td><span style="color: red; ">VStoreEnter</span>
    </td>
    <td><span style="color: red; ">VStoreExit</span>
    </td>
  </tr>
  <tr>
    <td>MonitorEnter
    </td>
    <td><span style="color: red; ">EnterLoad</span>
    </td>
    <td><span style="color: red; ">EnterStore</span>
    </td>
    <td><span style="color: red; ">EnterVLoad</span>
    </td>
    <td><span style="color: red; ">EnterVStore</span>
    </td>
    <td><span style="color: red; ">EnterEnter</span>
    </td>
    <td><span style="color: red; ">EnterExit</span>
    </td>
  </tr>
  <tr>
    <td>MonitorExit
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><span style="color: red; ">ExitVLoad</span>
    </td>
    <td><span style="color: red; ">ExitVStore</span>
    </td>
    <td><span style="color: red; ">ExitEnter</span>
    </td>
    <td><span style="color: red; ">ExitExit</span>
    </td>
  </tr>
  </tbody>
</table>
<p>
</p>

<p> Plus the special final-field rule requiring
<span style="color: red; ">StoreStore</span> and
<span color="red">StoreVStore</span> barriers in:
<br> &nbsp; &nbsp; &nbsp;
<tt>x.finalField = v; <span style="color: red; ">StoreStore</span>;
sharedNonVolatileRef = x;</tt>
<br> &nbsp; &nbsp; &nbsp;
<tt>x.finalField = v; <span style="color: red; ">StoreVStore</span>;
sharedVolatileRef = x;</tt>
</p>

<p>
    To be clear about both the purpose and utility of this matrix:
    This matrix is NOT an attempt to capture a precise description of the JMM.
    Instead, it is intended to be less-or-equal to the JMM in strictness, with
    every single barrier in the matrix being absolutely required by the JMM,
    but with some JMM rules not necessarily being captured.
    If the matrix achieves this goal, developers can safely assume that all
    the reordering rules stated in it are actually followed by all JVMs that
    comply with the JMM. It is certainly possible that (and acceptable for)
    the JMM to be more strict than the rules described in the matrix. It is
    certainly possible for JVMs to be more strict.
</p>

<p>
    I hold some *hope* that either the current or a future JMM spec <td><span style="color: red; ">guarantees</span>
    every single one of the orderings in the above matrix. Since the orderings
    stated can be reasoned above in a transitive fashion, they provide a convenient
    recipe for developers to follow in determining which reorderings are impossible
    in their code.
</p>

<p>
    We now embark on trying to show how each of the above reorderings is
    guaranteed by the JMM specification: This exercise is left for the reader ;-).
</p>

<p>
    Starting on that exercise though, much of the matrix can simply be attributed to this single
    statement in the JMM specification
    <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.4">(17.4.4)</a>:
    <br>
    <span style="font-family: courier new; font-size:14px;">"Every execution has a synchronization order.
    A synchronization order is a total order over all of the synchronization actions of an
    execution. For each thread t, the synchronization order of the synchronization actions
    <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.2">(17.4.2)</a>
    in t is consistent with the program order
    <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.3">(17.4.3)</a>
    of t."</span>
    <br>
    To my current understanding, this single statement, on it's own, covers the bottom right 4x4 part
    of the matrix, requiring each of the barriers stated between any combination of a Volatile Load,
    Volatile Store, Monitor Enter, and Monitor Exit (all of which are synchronization actions per
    <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.2">(17.4.2)</a>).
</p>
 <p>
    This leaves us with only 8 other barriers to prove. I worry that they may require adding "specific
     variable" statements to be actually required...
</p>

<!-- hhmts start --> Last modified: Tue Feb 23 09:10:36 PST 2014 <!-- hhmts end -->

</body>
</html>
