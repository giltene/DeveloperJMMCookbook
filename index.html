<!DOCTYPE html>
<html>
<head>
<title>The JMM Cookbook for Java Developers</title>

<meta http-equiv="content-type"
content="text/html; charset=ISO-8859-1">

<meta name="author" content="Gil Tene">
</head>
<body style="background-color: #ffffee;">

<h1>The JMM Cookbook for Java Developers</h1>

by <a href="https://twitter.com/giltene">Gil Tene</a>, with help from
a sleepless night and confusion about which day it was.

<p> 
<a href="http://g.oswego.edu/dl/jmm/cookbook.html">
Doug Lea's JSR-133 Cookbook for Compiler Writers
</a>
(aka "the JMM cookbook") descibes a set of implementation rules that is
sufficient for meeting the JMM specification. The simple ordering
matrices described provide great guidlines that rae easy to follow and
reason about. 
</p>

<p> 
However, while many JVM implementations follow these cookbook rules in
order to meet the JMM specification, it can be dangerous for Java
developers to assume that the rules stated are guarantees, since JVM
implementations that meet the JMM specification but use more relaxed rules
that stated in the JMM cookbook are possible. The barrier matrices,
as easy as they are to understand and follow, are not a reliable
predictor of what JVMs will actually do now or in the future.
</p>

<p> 
This leaves developers with the burden of trying to reason about their
programs using the JMM spec itself, which proves to be a task so hard
that is hard for the concurrency experts involved in specifying,
implementing and testing it (as evidenced by active discussion bursts
on various related mailing lists)..
</p>

<h3>Gil's expanded barrier table</h3>

<p> 
I've been playing with an attempt to describe the required (rather than
just a sufficient) reordering limitations that result from the JMM spec
in a way that can be more readily consumed by Java developers that want
to reason about their own programs, and to understand the guarantees
provided to them by the JMM.
</p>

<p> 
I believe that the following matix, using Doug's convenient format,
describes required (rather than simply sufficient) reordering rules
between the common operations of Load, Store, Volatile Load, Volatile Store,
Monitor Enter, and Monitor Exit.
</p>

<p>
The matrix uses Doug's original notation for  
<span style="color: red; ">LoadLoad</span>,
<span style="color: red; ">LoadStore</span>,
<span style="color: red; ">StoreStore</span> and
<span style="color: red; ">StoreLoad</span> barriers used in the JMM cookbook's
most commonly referred to matrix, in
addition to his expanded use of the following:
<span style="color: red; ">LoadExit</span>,
<span style="color: red; ">StoreExit</span>,
<span style="color: red; ">EnterEnter</span>,
<span style="color: red; ">EnterExit</span>,
<span style="color: red; ">ExitExit</span>,
<span style="color: red; ">ExitEnter</span>,
<span style="color: red; ">EnterLoad</span>,
<span style="color: red; ">EnterStore</span>.
Into that mix, We throw in the additional
<span style="color: red; ">"VLoad"</span> and
<span style="color: red; ">"VStore"</span>
notation to expand the set with
<span style="color: red; ">LoadVStore</span>,
<span style="color: red; ">LoadVLoad</span>,
<span style="color: red; ">StoreVStore</span>,
<span style="color: red; ">VLoadLoad</span>,
<span style="color: red; ">VLoadStore</span>,
<span style="color: red; ">VLoadVLoad</span>,
<span style="color: red; ">VLoadVStore</span>,
<span style="color: red; ">VLoadEnter</span>,
<span style="color: red; ">VLoadExit</span>,
<span style="color: red; ">VStoreVLoad</span>,
<span style="color: red; ">VStoreVStore</span>,
<span style="color: red; ">VStoreEnter</span>,
<span style="color: red; ">VStoreExit</span>,
<span style="color: red; ">ExitVLoad</span>,
<span style="color: red; ">ExitVStore</span>.



<p> I believe that Fully expanding to explicitly address ordering rules for Loads, Stores, Volatile Loads, Volatile Stores, Monitor Enter and Monitor Exit disentangles to: </p>

<table cellpadding="2" cellspacing="2" border="1" >
  <tbody>
  <tr>
    <td><b>Required Barriers</b>
    </td>
    <td rowspan="1" colspan="6" align="center"><em>2nd operation</em>
    </td>
  </tr>
  <tr>
    <td><em>1st operation</em>
    </td>
    <td>Normal Load
    </td>
    <td>Normal Store
    </td>
    <td>Volatile Load
    </td>
    <td>Volatile Store
    </td>
    <td>MonitorEnter
    </td>
    <td>MonitorExit
    </td>
  </tr>
  <tr>
    <td>Normal Load
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><span style="color: red; ">LoadVStore</span>
    </td>
    <td><br>
    </td>
    <td><span style="color: red; ">LoadExit</span>
    </td>
  </tr>
  <tr>
    <td>Normal Store
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><span style="color: red; ">StoreVStore</span>
    </td>
    <td><br>
    </td>
    <td><span style="color: red; ">StoreExit</span>
    </td>
  </tr>
  <tr>
    <td>Volatile Load
    </td>
    <td><span style="color: red; ">VLoadLoad</span>
    </td>
    <td><span style="color: red; ">VLoadStore</span>
    </td>
    <td><span style="color: red; ">VLoadVLoad</span>
    </td>
    <td><span style="color: red; ">VLoadVStore</span>
    </td>
    <td><span style="color: red; ">VLoadEnter</span>
    </td>
    <td><span style="color: red; ">VLoadExit</span>
    </td>
  </tr>
  <tr>
    <td>Volatile Store
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><span style="color: red; ">VStoreVLoad</span>
    </td>
    <td><span style="color: red; ">VStoreVStore</span>
    </td>
    <td><span style="color: red; ">VStoreEnter</span>
    </td>
    <td><span style="color: red; ">VStoreExit</span>
    </td>
  </tr>
  <tr>
    <td>MonitorEnter
    </td>
    <td><span style="color: red; ">EnterLoad</span>
    </td>
    <td><span style="color: red; ">EnterStore</span>
    </td>
    <td><span style="color: red; ">EnterVLoad</span>
    </td>
    <td><span style="color: red; ">EnterVStore</span>
    </td>
    <td><span style="color: red; ">EnterEnter</span>
    </td>
    <td><span style="color: red; ">EnterExit</span>
    </td>
  </tr>
  <tr>
    <td>MonitorExit
    </td>
    <td><br>
    </td>
    <td><br>
    </td>
    <td><span style="color: red; ">ExitVLoad</span>
    </td>
    <td><span style="color: red; ">ExitVStore</span>
    </td>
    <td><span style="color: red; ">ExitEnter</span>
    </td>
    <td><span style="color: red; ">ExitExit</span>
    </td>
  </tr>
  </tbody>
</table>
<p>
</p>

<p> Plus the special final-field rule requiring
<span style="color: red; ">StoreStore</span> and
<span color="red">StoreVStore</span> barriers in:
<br> &nbsp; &nbsp; &nbsp;
<tt>x.finalField = v; <span style="color: red; ">StoreStore</span>;
sharedNonVolatileRef = x;</tt>
<br> &nbsp; &nbsp; &nbsp;
<tt>x.finalField = v; <span style="color: red; ">StoreVStore</span>;
sharedVolatileRef = x;</tt>
</p>

<p> 
To be clear about both the purpose and utility of this matrix:
This matrix is NOT an attempt to capture a precise description of the JMM.
Instead, it is intended to be At-least-as-strict as the JMM, such that
developers can safely assume that all the reordering rules stated in it are
actually followed by all JVMs that comply with the JMM. It is certainly
possible that (and acceptable for) the JMM to be more strict than the
rules described in the matrix. It is certainly possible for JVMs to be
more strict.
</p>

<p>
I *think* (hope?) that the JMM spec <td><span style="color: red; ">guarantees</span> every
single one of the orderings in the above matrix. Since the orderings stated
can be reasoned above in a transitive fashion, they provide a convenient recepie
for developers to follow in determining which reorderings are impossible in their
code.
</p>

<p>
    We now embark on trying to show how each of the above reorderings is
    guaranteed by the JMM specification: This exercise is left for the reader ;-).
</p>

<p>
    Staring on that exercise though, much of the matrix can simply be attributed to this single
    statement in the JMM specification
    <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.4">(§17.4.4)</a>:
    <br>
    <span style="font-family: courier new; font-size:14px;">"Every execution has a synchronization order.
    A synchronization order is a total order over all of the synchronization actions of an
    execution. For each thread t, the synchronization order of the synchronization actions
    <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.2">(§17.4.2)</a>
    in t is consistent with the program order
    <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.3">(§17.4.3)</a>
    of t."</span>
    <br>
    To my current understanding, this single statement, on it's own, covers the bottom right 4x4 part
    of the matrix, requiring each of the barriers stated between any combination of a Volatile Load,
    Volatile Store, Monitor Enter, and Monitor Exit (all of which are synchronization actions per
    <a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4.2">(§17.4.2)</a>).
</p>
 <p>
    This leaves us with only 8 other barriers to prove.
</p>

<!-- hhmts start --> Last modified: Tue Feb 23 09:10:36 PST 2014 <!-- hhmts end -->

</body>
</html>
